/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package in.ac.dei.mhrd.omr;

import in.ac.dei.mhrd.omr.img.FileClass;
import in.ac.dei.mhrd.omr.img.RotateImg;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.log4j.xml.DOMConfigurator;
import in.ac.dei.mhrd.omr.img.*;
import java.sql.*;

/**
 * MyEclipse Struts Creation date: 09-29-2010
 * @author Anshul Agarwal
 * XDoclet definition:
 * 
 * @struts.action path="/processSheet" name="processSheetForm"
 *                input="/ProcessSheet.jsp" scope="request" validate="true"
 *                
 *  This class fetches the testname selected by the user to process the response sheets,
 *  locates the corresponding zipped folder on the server ,
 *  extracts the files from the zipped file into a folder, delete the zipped file
 *  creates the rejected folder and processed folder on the server if not created,
 *  process the sheets extracted from the zipped folder, 
 *  transfers the sheets into rejected folder or processed folder accordingly.              
 */

public class ProcessSheetAction extends Action {

	File unzippFolder;
	public static String RejectedFolderPath;

	/*
	 * Generated Methods
	 */

	/**
	 * @param filename
     * This function extracts the files from the zipped folder
	 */
	public void getZipFiles(String filename) {
		try {

			File zipFolder = new File(filename);

			String destinationname = zipFolder.getParent();

			byte[] buf = new byte[1024];
			ZipInputStream zipinputstream = null;
			ZipEntry zipentry;
			zipinputstream = new ZipInputStream(new FileInputStream(filename));

			zipentry = zipinputstream.getNextEntry();

			while (zipentry != null) {
				// for each entry to be extracted
				String entryName = zipentry.getName();

				int fileData;
				FileOutputStream fileoutputstream;
				File newFile = new File(entryName);
				String directory = newFile.getParent();
				System.out.println(directory);

				if (directory == null) {
					if (newFile.isDirectory()) {
						System.out.println("directory found");

						break;
					}
				}

				unzippFolder = new File(destinationname + "\\" + directory);
				unzippFolder.mkdir();
				fileoutputstream = new FileOutputStream(destinationname + "\\"
						+ entryName);

				while ((fileData = zipinputstream.read(buf, 0, 1024)) > -1)
					fileoutputstream.write(buf, 0, fileData);

				fileoutputstream.close();
				zipinputstream.closeEntry();
				zipentry = zipinputstream.getNextEntry();
			} // while

			zipinputstream.close();
		} catch (Exception e) {
			log.error("Error while extracting files from the zipped folder : " +e);
			e.printStackTrace();
		}
	}

	private static Logger log = Logger.getLogger(ProcessSheetAction.class);

	/**
	 * This method process the response sheets of the candidate, move the rejected sheets to rejectedfolder and processed sheets to processedfolder 
	 * on the server.
	 * Method execute
	 * 
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 */

	public ActionForward execute(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response) {
		ProcessSheetForm processSheetForm = (ProcessSheetForm) form;// TODO
															// Auto-generated
																	// method
																// stub
		String path = "";
		File ProcessedFolder = null;
		File rejectedFolder = null;
		String[] countinputFolderSheet = null;
		int testid;
		int totalQues = 0;
		int totatSec = 0;
		String testName = processSheetForm.getTestName();
		if(testName.equals("0")){
			System.out.println("no test name " +testName);
			request.setAttribute("ProcessSheetMsg", "Please select a test name");

		}
		else{
		int no_of_sheets = 0;
		String pathFlag;
		pathFlag = processSheetForm.getProcessSheetPath();
		
			request.setAttribute("ProcessSheetMsg", " ");

			/*
			 * this code ret
			 * 
			 */
			try {

				java.sql.Connection con =  Connect.prepareConnection();
                
				con.setAutoCommit(false);
				
				PreparedStatement ps = con
						.prepareStatement("select  TestId, Total_question, Total_section from testheader where Test_name = ?");
				ps.setString(1, testName);
				ResultSet rs = ps.executeQuery();
				rs.next();
				testid = rs.getInt(1);
				totalQues = rs.getInt(2);
				totatSec = rs.getInt(3);
				log.info("test Id retrieved : " + testid);

				/*
				 * This section of code sets the date and time when processing
				 * of the sheets starts
				 */

				ps = con.prepareStatement("update testheader set ProcessStartDate=now(), Test_status = 'S' where Test_name=?");
				ps.setString(1, testName);
				int updateStatus = ps.executeUpdate();
				con.commit();
				System.out.println("update : " + updateStatus);
				ArrayList<String> pathInfo = new ArrayList<String>();// To
																		// store
																		// the
																		// path
																		// of
																		// all
																		// images
																		// in
																		// the
																		// folder

				// String s = processSheetForm.getProcessSheetPath();
				String imgPath = getServlet().getServletContext().getRealPath(
						"/")
						+ "inputFolder" + "//" + testName;

				ProcessedFolder = new File(getServlet().getServletContext()
						.getRealPath("/")
						+ "processedFolder" + "/" + testid);

				RejectedFolderPath = getServlet().getServletContext()
						.getRealPath("/")
						+ "RejectedFolder" + "/" + testid;
				rejectedFolder = new File(getServlet().getServletContext()
						.getRealPath("/")
						+ "RejectedFolder" + "/" + testid);

				/* creates the rejected folder if it does not exists */
				
				if (!rejectedFolder.exists()) {
					log.info(" inside rejected ");
					rejectedFolder.mkdirs();
				}

				/* if process folder has not yet been created, then create it */

				System.out.println("2");
				if (!ProcessedFolder.exists()) {
					System.out.println("3");

					ProcessedFolder.mkdirs();
				}
				File testNameFolder = new File(imgPath);

				File[] zippFile = testNameFolder.listFiles();

				/*
				 * checking whether sheets from input folder has been extracted
				 * from zipped file or not
				 */

				if (zippFile[0].isFile()) {
					System.out.println("zipped file found");
					imgPath = zippFile[0].toString();
					System.out.println("img path :" + imgPath);
					// extract files from the zipped folder
					getZipFiles(imgPath);

					path = unzippFolder.getAbsolutePath();
					countinputFolderSheet = unzippFolder.list();

					// Delete the zipped folder once the sheets has been
					// extracted
					File del = new File(imgPath);
					del.delete();
				} else {
					path = zippFile[0].getPath();
				}
				FileClass fc = new FileClass();

				// this function returns the list of bmp files in the input
				// folder and move other files to the rejected folder
				pathInfo = fc.pathfunc(path, testid, RejectedFolderPath);

				for (String filepath : pathInfo) { // Each file is extracted &
													// pass to the system for
													// further processing
					System.out.println("Executing:" + filepath);
					no_of_sheets++;

					RotateImg obj = new RotateImg();

					obj.processSheet(filepath, testid, totalQues); // process
																	// the sheet
																	// further

					File source = new File(filepath);

					boolean flag = source.renameTo(new File(ProcessedFolder,
							source.getName()));
					
					log.info("move file status " + flag);
					System.gc();
				}
					String[] countRejectedFolder = rejectedFolder.list();
					String[] countProcessedSheet = ProcessedFolder.list();
					/*
					 * if all sheets in the input folder are processed, and
					 * transferred to rejected and processed folder accordingly,
					 * Test_status is set to 'P' and Default result date is
					 * inserted
					 */
                    request.setAttribute("TotalSheets", countinputFolderSheet.length);
                    request.setAttribute("ProcessedSheets", countProcessedSheet.length);
                    request.setAttribute("RejectedSheets", countRejectedFolder.length);
					if (countinputFolderSheet.length == (countProcessedSheet.length + countRejectedFolder.length)){
						try{
					ps = con.prepareStatement("update testheader set ProcessEndDate=now(), Test_status = 'P', ResultDisplayedFrom=now(), ResultDisplayedTo = DATE_ADD(now() ,INTERVAL '7' Day) where TestId=?");
					ps.setInt(1, testid);
					int updateTestHeaderStatus = ps.executeUpdate();
					con.commit();
					if (updateTestHeaderStatus != 1) {
						log.error("test Header couldn't updated after processing completes");
					}
						}catch (Exception e) {
							// TODO: handle exception
							log.error("Error in update test header in Process Action : "+ e);
						}
						
					
					/*
					 * set total number of sheets in the input folder, rejected
					 * folder and
					 */
					ps = con.prepareStatement("insert into testlog (TotalSheets, ProcessedSheets, RejectedSheets, Testid) values(?,?,?,?)");
					ps.setInt(1, countinputFolderSheet.length);
					ps.setInt(2, countProcessedSheet.length);
					ps.setInt(3, countRejectedFolder.length);
					ps.setInt(4, testid);
					int updatetestLog = ps.executeUpdate();
					con.commit();
					if (updatetestLog != 1) {
						
						log.error("test log couldn't updated after processing completes");

					}

					// delete the input folder if all sheets are processed
					System.out.println(" input folder to be deleted + "+ unzippFolder.getParentFile());
					unzippFolder.delete();
					unzippFolder.getParentFile().delete();
					

				}
				
			} catch (Exception e) {

				log.error("error in Process Actio  : " + e);
				System.out.println("Error in Process Action " +e);

			}
		//}
		//request.setAttribute("TotalSheets", no_of_sheets);
		}//end else

		return mapping.findForward("index");
	}

}